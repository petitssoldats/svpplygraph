// Generated by CoffeeScript 1.4.0
(function() {
  var RelationnalGraph,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  RelationnalGraph = (function() {
    var categorieGravity, collide, color, createLinks, definePriceCat, downprice, findLink, findProduct, priceGravity, setColor, setRadius, upprice;

    function RelationnalGraph(parent) {
      this.tick = __bind(this.tick, this);
      this.properties = {};
      this.properties.width = 1000;
      this.properties.height = 600;
      this.properties.datum = [];
      this.properties.linkAccuracy = 3;
      this.properties.cacheImage = new Array();
      this.properties.scale = upprice;
      this.properties.priceCat = false;
      this.properties.productCat = false;
      this.categories = [[], [], [], [], [], []];
      this.properties.mouseover = function() {};
      this.properties.mouseout = function() {};
      this.svg = parent.append('svg');
      this.main = this.svg.append('g').attr('class', 'main');
      this.force = d3.layout.force().size([this.properties.width, this.properties.height]).nodes([]).linkDistance(100).charge(-60);
      this.nodes = this.force.nodes();
      this.links = this.force.links();
      this.node = this.svg.selectAll(".node");
      this.link = this.svg.selectAll(".link");
      this.force.on("tick", this.tick);
      this.properties.categoriesColor = [
        {
          name: "Women’s",
          color: "#753863"
        }, {
          name: "Men’s",
          color: "#f94142"
        }, {
          name: "Tech",
          color: "#2a638b"
        }, {
          name: "Media",
          color: "#47a3af"
        }, {
          name: "Home",
          color: "#5aaf78"
        }, {
          name: "Art",
          color: "#5ad89a"
        }, {
          name: "Other",
          color: "#535b6a"
        }
      ];
      return this;
    }

    RelationnalGraph.prototype.update = function() {
      var index, item, key, l, link, _i, _j, _len, _len1, _links, _ref, _ref1, _self,
        _this = this;
      _self = this;
      _ref = this.links;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        link = _ref[index];
        this.links.splice(0, 1);
      }
      _ref1 = this.properties.links;
      for (key in _ref1) {
        item = _ref1[key];
        if (item.products.length > 1 && item.username !== 'forestier_mk') {
          _links = createLinks(item.products, this.properties.datum, this.properties.linkAccuracy);
          for (_j = 0, _len1 = _links.length; _j < _len1; _j++) {
            link = _links[_j];
            l = findLink(link.source.id, link.target.id, this.links);
            if (!l) {
              this.links.push(link);
            } else {
              l.source.weight *= 10;
              l.target.weight *= 10;
            }
          }
        }
      }
      setRadius(this.nodes, this.properties.scale);
      this.svg.attr('width', this.properties.width).attr('height', this.properties.height);
      this.force.size([this.properties.width, this.properties.height]);
      this.link = this.link.data(this.links);
      this.node = this.node.data(this.nodes);
      this.link.enter().insert("line", ".node").style('stroke-width', 0.5).attr("class", "link");
      this.link.exit().remove();
      this.node.enter().insert("circle", ".cursor").style('fill', function(d, i) {
        return d.color;
      }).style('stroke', function(d, i) {
        return d.color;
      }).style('stroke-width', 2).style('fill-opacity', function(d, i) {
        if (!d.own) {
          return 1;
        } else {
          return 0.5;
        }
      }).attr("class", "node");
      this.node.transition().duration(1000).attr("r", function(d) {
        return d.radius;
      });
      this.node.on('mouseover', function(d) {
        d3.select(this).transition().duration(100).style('fill', '#0586ff');
        return _self.properties.mouseover(d3.select(this).node(), d);
      }).on('mouseout', function(d) {
        var _this = this;
        d3.select(this).transition().duration(100).style('fill', function(d, i) {
          return d.color;
        });
        return _self.properties.mouseout(d3.select(this).node(), d);
      }).on('click', function(d) {
        window.open(d.url);
        return console.log(d);
      });
      this.force.start();
      return this;
    };

    RelationnalGraph.prototype.attr = function(attribut, value) {
      var categorie, i, index, item, m, productCategories, _i, _j, _len, _len1, _ref, _ref1, _x;
      switch (attribut) {
        case 'width':
          if (!(value != null)) {
            return this.properties.width;
          }
          this.properties.width = value;
          break;
        case 'height':
          if (!(value != null)) {
            return this.properties.height;
          }
          this.properties.height = value;
          break;
        case 'datum':
          if (!(value != null)) {
            return this.properties.datum;
          }
          this.properties.datum = value;
          m = 8;
          _x = d3.scale.ordinal().domain(d3.range(m)).rangePoints([0, this.properties.width], 1);
          _ref = this.properties.datum;
          for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
            item = _ref[index];
            i = definePriceCat(item.price[0]);
            productCategories = item.categories[1];
            _ref1 = this.properties.categoriesColor;
            for (index = _j = 0, _len1 = _ref1.length; _j < _len1; index = ++_j) {
              categorie = _ref1[index];
              if (item.categories[1] === categorie.name) {
                item.color = categorie.color;
                item.categorie = index;
              }
            }
            this.properties.cacheImage[index] = new Image();
            this.properties.cacheImage[index].src = item.img;
            item.x = Math.random() * this.properties.width;
            item.y = 20;
            item.cx = _x(i);
            item.cy = this.properties.height / 2;
            item.catx = _x(item.categorie);
            item.caty = this.properties.height / 2;
            this.nodes.push(item);
          }
          break;
        case 'links':
          if (!(value != null)) {
            return this.properties.links;
          }
          this.properties.links = value;
          break;
        case 'mouseover':
          if (!(value != null)) {
            return this.properties.mouseover;
          }
          this.properties.mouseover = value;
          break;
        case 'mouseout':
          if (!(value != null)) {
            return this.properties.mouseout;
          }
          this.properties.mouseout = value;
          break;
        case 'scale':
          if (!(value != null)) {
            return this.properties.scale;
          }
          if (value === 'up') {
            this.properties.scale = upprice;
          } else {
            this.properties.scale = downprice;
          }
          break;
        case 'priceGravity':
          if (!(value != null)) {
            return this.properties.priceCat;
          }
          this.properties.priceCat = value;
          this.force.start();
          break;
        case 'productCat':
          if (!(value != null)) {
            return this.properties.productCat;
          }
          this.properties.productCat = value;
          this.force.start();
      }
      return this;
    };

    RelationnalGraph.prototype.tick = function(e) {
      var count, l, q;
      this.link.attr("x1", function(d) {
        return d.source.x;
      }).attr("y1", function(d) {
        return d.source.y;
      }).attr("x2", function(d) {
        return d.target.x;
      }).attr("y2", function(d) {
        return d.target.y;
      });
      this.node.attr("cx", function(d) {
        return d.x;
      }).attr("cy", function(d) {
        return d.y;
      });
      if (this.properties.priceCat) {
        this.node.each(priceGravity(0.2 * e.alpha));
      }
      if (this.properties.productCat) {
        this.node.each(categorieGravity(0.2 * e.alpha));
      }
      q = d3.geom.quadtree(this.nodes);
      l = this.nodes.length;
      count = 0;
      while (count !== l) {
        q.visit(collide(this.nodes[count]));
        count += 1;
      }
      return this;
    };

    RelationnalGraph.prototype.select = function(title) {
      var item, _i, _len, _ref, _select,
        _this = this;
      if (title != null) {
        this.node.transition().duration(100).attr("r", function(d) {
          return d.radius;
        }).style('fill', function(d, i) {
          return setColor(d, i, _this.properties.datum.length);
        });
        _select = null;
        _ref = this.properties.datum;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          if (item.title === title) {
            this.node.filter(function(d) {
              return d.id === item.id;
            }).transition().duration(100).style('fill', '#0586ff');
            console.log(item);
          }
        }
      } else {
        console.log('nope');
      }
      return this;
    };

    /* --- PRIVATE ---
    */


    upprice = d3.scale.sqrt().domain([1, 20, 50, 100, 200, 500, 5000]).range([5, 10, 15, 20, 25, 30, 40]);

    downprice = d3.scale.sqrt().domain([1, 20, 50, 100, 200, 500, 5000]).range([50, 20, 15, 10, 8, 6, 4]);

    setColor = function(d, i, categoriesColor) {
      var _C, _c;
      _C = null;
      if (!d.own) {
        _c = d.color;
      } else {
        _c = "black";
      }
      return _c;
    };

    setRadius = function(array, scale) {
      var item, _i, _len, _max;
      _max = d3.max(array, function(d) {
        return d.price[0];
      });
      scale.domain([1, 20, 50, 100, 200, 500, _max]);
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        item = array[_i];
        item.radius = scale(item.price[0]) / 2;
      }
    };

    createLinks = function(arrayID, arrayProduct, linkAccuracy) {
      var accuracy, cat, id, index, result, source, ta, target, _i, _j, _k, _len, _len1, _len2, _ref;
      result = [];
      for (_i = 0, _len = arrayID.length; _i < _len; _i++) {
        id = arrayID[_i];
        source = findProduct(id, arrayProduct);
        for (_j = 0, _len1 = arrayID.length; _j < _len1; _j++) {
          ta = arrayID[_j];
          if (id !== ta) {
            target = findProduct(ta, arrayProduct);
            accuracy = 0;
            _ref = target.categories;
            for (index = _k = 0, _len2 = _ref.length; _k < _len2; index = ++_k) {
              cat = _ref[index];
              if (cat === source.categories[index]) {
                accuracy += 1;
              }
            }
            if (accuracy > linkAccuracy) {
              result.push({
                source: source,
                target: target
              });
            }
          }
        }
      }
      return result;
    };

    findProduct = function(id, arrayProduct) {
      var product, result, _i, _len;
      result = null;
      for (_i = 0, _len = arrayProduct.length; _i < _len; _i++) {
        product = arrayProduct[_i];
        if (product.id === id) {
          result = product;
        }
      }
      return result;
    };

    findLink = function(id1, id2, links) {
      var link, result, _i, _len;
      result = false;
      for (_i = 0, _len = links.length; _i < _len; _i++) {
        link = links[_i];
        if (link.source.id === id1) {
          if (link.target.id === id2) {
            result = link;
          }
        } else if (link.source.id === id2) {
          if (link.target.id === id1) {
            result = link;
          }
        }
      }
      return result;
    };

    collide = function(node) {
      var nx1, nx2, ny1, ny2, r;
      r = node.radius + 50;
      nx1 = node.x - r;
      nx2 = node.x + r;
      ny1 = node.y - r;
      ny2 = node.y + r;
      return function(quad, x1, y1, x2, y2) {
        var l, x, y;
        if ((quad.point != null) && quad.point !== node) {
          x = node.x - quad.point.x;
          y = node.y - quad.point.y;
          l = Math.sqrt(x * x + y * y);
          r = node.radius + quad.point.radius;
          if (l < r) {
            l = (l - r) / l * 0.5;
            node.x -= x *= l;
            node.y -= y *= l;
            quad.point.x += x;
            quad.point.y += y;
          }
        }
        return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
      };
    };

    definePriceCat = function(price) {
      var result;
      result = 0;
      if ((500 <= price && price <= 5000)) {
        result = 1;
      } else if ((200 <= price && price <= 500)) {
        result = 2;
      } else if ((100 <= price && price <= 200)) {
        result = 3;
      } else if ((50 <= price && price <= 100)) {
        result = 4;
      } else if ((20 <= price && price <= 50)) {
        result = 5;
      } else if ((1 <= price && price <= 20)) {
        result = 6;
      }
      return result;
    };

    priceGravity = function(alpha) {
      return function(d) {
        d.x += (d.cx - d.x) * alpha;
        return d.y += (d.cy - d.y) * alpha;
      };
    };

    categorieGravity = function(alpha) {
      return function(d) {
        d.x += (d.catx - d.x) * alpha;
        return d.y += (d.caty - d.y) * alpha;
      };
    };

    color = d3.scale.linear().range(['#fb4e07', '#1a113a']);

    return RelationnalGraph;

  })();

  window.RelationnalGraph = RelationnalGraph;

}).call(this);
